{
    "Binary Search Support":{
        "prefix": "XbSearch",
        "body":[
            "int lo=0, hi=n-1;",
            "while(lo<=hi){",
            "    int mid = lo+(hi-lo)/2;",
            "    // operation",
            "}"
        ],
        "description": "Snippet for simple Binary Search"
    },

    "Linked List Form":{
        "prefix": "XLLStruct",
        "body":[
            "struct ListNode{",
            "    int data;",
            "    ListNode* next;",
            "    ListNode(int data1){",
            "        data=data1;",
            "        next=NULL;",
            "    }",
            "};",
        ],
        "description": "Snippet for ListNode definition"
    },

    "Linked List Insert": {
        "prefix": "XLLInsert",
        "body": [
          "// Function to insert a node at the beginning of the linked list.",
          "ListNode *insertAtBegining(ListNode *head, int x) {",
          "    ListNode* a = new ListNode(x);",
          "    a->next = head;",
          "    return a;",
          "}",
          "",
          "// Function to insert a node at the end of the linked list.",
          "ListNode *insertAtEnd(ListNode *head, int x) {",
          "    ListNode* a = new ListNode(x);",
          "    if (head == NULL) {",
          "        return a;",
          "    }",
          "    ListNode* tail = head;",
          "    while (tail->next != NULL) {",
          "        tail = tail->next;",
          "    }",
          "    tail->next = a;",
          "    return head;",
          "}",
          "",
          "// Function to insert a node at the given position of the linked list.",
          "ListNode *insertAtPos(ListNode *head, int x, int pos) {",
          "    if (pos == 0) return insertAtBegining(head, x);",
          "    if (pos == -1) return insertAtEnd(head, x);",
          "    ListNode* a = new ListNode(x);",
          "    ListNode* prev = head;",
          "    for (int i = 0; i < pos - 2; i++) {",
          "        prev = prev->next;",
          "    }",
          "    ListNode* next = prev->next;",
          "    prev->next = a;",
          "    a->next = next;",
          "    return head;",
          "}"
        ],
        "description": "Insert a node into a linked list."
    },

    "Linked List Delete": {
        "prefix": "XLLDelete",
        "body": [
          "// Function to delete the head node",
          "ListNode* deleteFromStart(ListNode* head) {",
          "    ListNode* x = head->next;",
          "    delete(head);",
          "    return x;",
          "}",
          "",
          "// Function to delete the end node",
          "ListNode* deleteFromEnd(ListNode* head) {",
          "    if (!head || head->next == NULL) return NULL;",
          "    ListNode* tail = head;",
          "    while (tail->next->next) {",
          "        tail = tail->next;",
          "    }",
          "    delete(tail->next);",
          "    tail->next = NULL;",
          "    return head;",
          "}",
          "",
          "// Function to delete the first occurrence of a value",
          "ListNode* deleteVal(ListNode* head, int val) {",
          "    ListNode* temp = head;",
          "    if (temp->data == val) return deleteFromStart(head);",
          "    while (temp->next && temp->next->data != val) {",
          "        temp = temp->next;",
          "    }",
          "    if (temp->next) {",
          "        ListNode* x = temp->next;",
          "        temp->next = x->next;",
          "        delete(x);",
          "    }",
          "    return head;",
          "}"
        ],
        "description": "Delete nodes from a linked list."
    },

    "Linked List Length": {
        "prefix": "XLLLength",
        "body": [
          "// Function to calculate the length of the linked list",
          "int length(ListNode* head) {",
          "    int length = 0;",
          "    ListNode* temp = head;",
          "    while (temp) {",
          "        length++;",
          "        temp = temp->next;",
          "    }",
          "    return length;",
          "}"
        ],
        "description": "Calculate the length of a linked list."
    },

    "Linked List Search": {
        "prefix": "XLLSearch",
        "body": [
          "// Function to search for a value in the linked list",
          "ListNode* search(ListNode* head, int val) {",
          "    ListNode* temp = head;",
          "    while (temp && temp->data != val) {",
          "        temp = temp->next;",
          "    }",
          "    return temp;",
          "}"
        ],
        "description": "Search for a value in a linked list."
    },

    "Linked List Reverse": {
        "prefix": "XLLReverse",
        "body": [
          "// Function to reverse the linked list",
          "ListNode* reverse(ListNode* head) {",
          "    ListNode* prev = NULL;",
          "    ListNode* temp = head;",
          "    while (temp) {",
          "        ListNode* next = temp->next;",
          "        temp->next = prev;",
          "        prev = temp;",
          "        temp = next;",
          "    }",
          "    return prev;",
          "}"
        ],
        "description": "Reverse a linked list."
    },
    
    "Find Middle Node": {
        "prefix": "XLLMiddleNode",
        "body": [
          "// Function to find the middle node of the linked list",
          "ListNode* middleNode(ListNode* head) {",
          "    ListNode* slow = head;",
          "    ListNode* fast = head;",
          "    while (fast && fast->next) {",
          "        slow = slow->next;",
          "        fast = fast->next->next;",
          "    }",
          "    return slow;",
          "}"
        ],
        "description": "Find the middle node of a linked list."
    },

    "Detect Cycle": {
        "prefix": "XLLDetectCycle",
        "body": [
          "// Function to detect a cycle in the linked list",
          "bool hasCycle(ListNode* head) {",
          "    ListNode* slow = head;",
          "    ListNode* fast = head;",
          "    while (fast && fast->next) {",
          "        slow = slow->next;",
          "        fast = fast->next->next;",
          "        if (slow == fast) {",
          "            return true;",
          "        }",
          "    }",
          "    return false;",
          "}"
        ],
        "description": "Detect a cycle in a linked list."
    },

    "Palindrome Check": {
        "prefix": "XLLPalindromeCheck",
        "body": [
          "// Function to find the middle node of the linked list for palindrome check",
          "ListNode* middleNodePalindrome(ListNode* head) {",
          "    ListNode* slow = head;",
          "    ListNode* fast = head;",
          "    while (fast && fast->next && fast->next->next) {",
          "        slow = slow->next;",
          "        fast = fast->next->next;",
          "    }",
          "    return slow;",
          "}",
          "",
          "// Function to reverse the linked list for palindrome check",
          "ListNode* reverseListPalindrome(ListNode* head) {",
          "    if (!head || !head->next) {",
          "        return head;",
          "    }",
          "    ListNode* prev = NULL;",
          "    ListNode* temp = head;",
          "    while (temp) {",
          "        ListNode* next = temp->next;",
          "        temp->next = prev;",
          "        prev = temp;",
          "        temp = next;",
          "    }",
          "    return prev;",
          "}",
          "",
          "// Function to check if a linked list is a palindrome",
          "bool isPalindrome(ListNode* head) {",
          "    if (!head) {",
          "        return true;",
          "    }",
          "    ListNode* mid = middleNodePalindrome(head);",
          "    ListNode* a = head;",
          "    ListNode* b = mid->next;",
          "    mid->next = NULL;",
          "    b = reverseListPalindrome(b);",
          "    while (a && b) {",
          "        if (a->data != b->data) {",
          "            return false;",
          "        }",
          "        a = a->next;",
          "        b = b->next;",
          "    }",
          "    return true;",
          "}"
        ],
        "description": "Check if a linked list is a palindrome."
    },

    "Sort Linked List": {
        "prefix": "XLLSortList",
        "body": [
          "// Function to merge two sorted lists",
          "ListNode* mergeTwoListsSort(ListNode* list1, ListNode* list2) {",
          "    ListNode* head = new ListNode(-1);",
          "    ListNode* temp = head;",
          "    while (list1 && list2) {",
          "        if (list1->data <= list2->data) {",
          "            temp->next = list1;",
          "            list1 = list1->next;",
          "            temp = temp->next;",
          "            temp->next = NULL;",
          "        } else {",
          "            temp->next = list2;",
          "            list2 = list2->next;",
          "            temp = temp->next;",
          "            temp->next = NULL;",
          "        }",
          "    }",
          "    if (list1)",
          "        temp->next = list1;",
          "    else",
          "        temp->next = list2;",
          "    ListNode* newHead = head->next;",
          "    delete (head);",
          "    return newHead;",
          "}",
          "",
          "// Function to find the middle node of the linked list for sorting",
          "ListNode* middleNodeSort(ListNode* head) {",
          "    ListNode *slow = head, *fast = head;",
          "    while (fast && fast->next && fast->next->next) {",
          "        slow = slow->next;",
          "        fast = fast->next->next;",
          "    }",
          "    return slow;",
          "}",
          "",
          "// Function to sort the linked list",
          "ListNode* sortList(ListNode* head) {",
          "    if (!head || !head->next)",
          "        return head;",
          "    ListNode* mid = middleNodeSort(head);",
          "    ListNode *a = head, *b = mid->next;",
          "    mid->next = NULL;",
          "    a = sortList(a);",
          "    b = sortList(b);",
          "    head = mergeTwoListsSort(a, b);",
          "    return head;",
          "}"
        ],
        "description": "Sort a linked list."
    },

    "Add Two Numbers": {
        "prefix": "XLLAddTwoNumbers",
        "body": [
          "// Function to reverse a linked list for adding two numbers",
          "ListNode* reverseAddingTwoNumbers(ListNode* head) {",
          "    ListNode* temp = head;",
          "    ListNode* prev = NULL;",
          "    while (temp) {",
          "        ListNode* next = temp->next;",
          "        temp->next = prev;",
          "        prev = temp;",
          "        temp = next;",
          "    }",
          "    return prev;",
          "}",
          "",
          "// Function to add two numbers represented by linked lists",
          "ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {",
          "    l1 = reverseAddingTwoNumbers(l1);",
          "    l2 = reverseAddingTwoNumbers(l2);",
          "    ListNode* dummy = new ListNode(-1);",
          "    ListNode* a = dummy;",
          "    int carry = 0;",
          "    while (l1 && l2) {",
          "        int val = l1->data + l2->data + carry;",
          "        a->next = new ListNode(val);",
          "        a = a->next;",
          "        carry = a->data / 10;",
          "        a->data %= 10;",
          "        ListNode* x = l1;",
          "        l1 = l1->next;",
          "        delete (x);",
          "        x = l2;",
          "        l2 = l2->next;",
          "        delete (x);",
          "    }",
          "    while (l1) {",
          "        int val = l1->data + carry;",
          "        a->next = new ListNode(val);",
          "        a = a->next;",
          "        carry = a->data / 10;",
          "        a->data %= 10;",
          "        ListNode* x = l1;",
          "        l1 = l1->next;",
          "        delete (x);",
          "    }",
          "    while (l2) {",
          "        int val = l2->data + carry;",
          "        a->next = new ListNode(val);",
          "        a = a->next;",
          "        carry = a->data / 10;",
          "        a->data %= 10;",
          "        ListNode* x = l2;",
          "        l2 = l2->next;",
          "        delete (x);",
          "    }",
          "    while (carry) {",
          "        int val = carry;",
          "        a->next = new ListNode(val);",
          "        a = a->next;",
          "        carry = a->data / 10;",
          "        a->data %= 10;",
          "    }",
          "    ListNode* head = dummy->next;",
          "    delete (dummy);",
          "    return reverseAddingTwoNumbers(head);",
          "}"
        ],
        "description": "Add two numbers represented by linked lists."
    },
    
    "TreeNode Structure": {
      "prefix": "XBTTreeNode",
      "body": [
        "struct TreeNode {",
        "    int data;",
        "    TreeNode* left;",
        "    TreeNode* right;",
        "    TreeNode(int data1) {",
        "        data = data1;",
        "        left = NULL;",
        "        right = NULL;",
        "    }",
        "};"
      ],
      "description": "TreeNode structure definition."
    },

    "Preorder Traversal": {
      "prefix": "XBTPreorder",
      "body": [
        "// Function to perform preorder traversal of a binary tree",
        "void preorder(TreeNode* root) {",
        "    if (root) {",
        "        cout << root->data << \" \";",
        "        preorder(root->left);",
        "        preorder(root->right);",
        "    }",
        "}"
      ],
      "description": "Preorder traversal of a binary tree."
    },

    "Postorder Traversal": {
      "prefix": "XBTPostorder",
      "body": [
        "// Function to perform postorder traversal of a binary tree",
        "void postorder(TreeNode* root) {",
        "    if (root) {",
        "        postorder(root->left);",
        "        postorder(root->right);",
        "        cout << root->data << \" \";",
        "    }",
        "}"
      ],
      "description": "Postorder traversal of a binary tree."
    },

    "Inorder Traversal": {
      "prefix": "XBTInorder",
      "body": [
        "// Function to perform inorder traversal of a binary tree",
        "void inorder(TreeNode* root) {",
        "    if (root) {",
        "        inorder(root->left);",
        "        cout << root->data << \" \";",
        "        inorder(root->right);",
        "    }",
        "}"
      ],
      "description": "Inorder traversal of a binary tree."
    },

    "Level Order Traversal": {
      "prefix": "XBTLevelOrder",
      "body": [
        "#include <vector>",
        "#include <queue>",
        "using namespace std;",
        "",
        "// Function to perform level order traversal of a binary tree",
        "vector<vector<int>> levelOrder(TreeNode* root) {",
        "    if (!root) {",
        "        return {};",
        "    }",
        "    vector<vector<int>> ans;",
        "    queue<TreeNode*> q;",
        "    q.push(root);",
        "    while (!q.empty()) {",
        "        int n = q.size();",
        "        vector<int> level;",
        "        for (int i = 0; i < n; i++) {",
        "            TreeNode* node = q.front();",
        "            q.pop();",
        "            level.push_back(node->data);",
        "            if (node->left) {",
        "                q.push(node->left);",
        "            }",
        "            if (node->right) {",
        "                q.push(node->right);",
        "            }",
        "        }",
        "        ans.push_back(level);",
        "    }",
        "    return ans;",
        "}"
      ],
      "description": "Level order traversal of a binary tree."
    },

    "Tree Height": {
      "prefix": "XBTTreeHeight",
      "body": [
        "#include <algorithm>",
        "using namespace std;",
        "",
        "// Function to calculate the height of a binary tree",
        "int height(TreeNode* root) {",
        "    if (!root)",
        "        return 0;",
        "    return 1 + max(height(root->left), height(root->right));",
        "}"
      ],
      "description": "Calculate the height of a binary tree."
    },

    "Check Balanced Tree": {
      "prefix": "XBTCheckBalanced",
      "body": [
        "#include <algorithm>",
        "#include <cmath>",
        "using namespace std;",
        "",
        "// Function to check the height and balance of a binary tree",
        "int heightIsBalanced(TreeNode* node) {",
        "    if (!node) {",
        "        return 0;",
        "    }",
        "",
        "    int lheight = heightIsBalanced(node->left);",
        "    int rheight = heightIsBalanced(node->right);",
        "",
        "    if (lheight == -1 || rheight == -1)",
        "        return -1;",
        "    if (abs(lheight - rheight) > 1)",
        "        return -1;",
        "    return 1 + max(lheight, rheight);",
        "}",
        "",
        "// Function to check if a binary tree is balanced",
        "bool isBalanced(TreeNode* root) {",
        "    if (!root)",
        "        return true;",
        "    int ans = heightIsBalanced(root);",
        "    return ans != -1;",
        "}"
      ],
      "description": "Check if a binary tree is height-balanced."
    },

    "Tree Diameter": {
      "prefix": "XBTTreeDiameter",
      "body": [
        "#include <algorithm>",
        "using namespace std;",
        "",
        "// Helper function to calculate the diameter of a binary tree",
        "int helperDiameter(TreeNode* root, int& ans) {",
        "    if (!root)",
        "        return 0;",
        "    if (!root->left && !root->right)",
        "        return 1;",
        "",
        "    int lheight = helperDiameter(root->left, ans);",
        "    int rheight = helperDiameter(root->right, ans);",
        "",
        "    ans = max(ans, lheight + rheight);",
        "",
        "    return 1 + max(lheight, rheight);",
        "}",
        "",
        "// Function to calculate the diameter of a binary tree",
        "int diameter(TreeNode* root) {",
        "    int ans = 0;",
        "    helperDiameter(root, ans);",
        "    return ans;",
        "}"
      ],
      "description": "Calculate the diameter of a binary tree."
    },

    "Check Same Tree": {
      "prefix": "XBTCheckSameTree",
      "body": [
        "// Function to check if two binary trees are the same",
        "bool isSameTree(TreeNode* p, TreeNode* q) {",
        "    if (!p && !q)",
        "        return true;",
        "    if (!p || !q)",
        "        return false;",
        "    if (p->data != q->data)",
        "        return false;",
        "    return (isSameTree(p->left, q->left) && isSameTree(p->right, q->right));",
        "}"
      ],
      "description": "Check if two binary trees are the same."
    },

    "Zigzag Level Order Traversal": {
      "prefix": "XBTZigzagLevelOrder",
      "body": [
        "#include <vector>",
        "#include <queue>",
        "#include <algorithm>",
        "using namespace std;",
        "",
        "// Helper function to perform level order traversal of a binary tree",
        "vector<vector<int>> levelOrderzz(TreeNode* root) {",
        "    if (!root) {",
        "        return {};",
        "    }",
        "    vector<vector<int>> ans;",
        "    queue<TreeNode*> q;",
        "    q.push(root);",
        "    while (!q.empty()) {",
        "        int n = q.size();",
        "        vector<int> level;",
        "        for (int i = 0; i < n; i++) {",
        "            TreeNode* node = q.front();",
        "            q.pop();",
        "            level.push_back(node->data);",
        "            if (node->left) {",
        "                q.push(node->left);",
        "            }",
        "            if (node->right) {",
        "                q.push(node->right);",
        "            }",
        "        }",
        "        ans.push_back(level);",
        "    }",
        "    return ans;",
        "}",
        "",
        "// Function to perform zigzag level order traversal of a binary tree",
        "vector<vector<int>> zigzagLevelOrder(TreeNode* root) {",
        "    vector<vector<int>> ans = levelOrderzz(root);",
        "    for (int i = 1; i < ans.size(); i += 2) {",
        "        reverse(ans[i].begin(), ans[i].end());",
        "    }",
        "    return ans;",
        "}"
      ],
      "description": "Zigzag level order traversal of a binary tree."
    },

    "Lowest Common Ancestor": {
      "prefix": "XBTLowestCommonAncestor",
      "body": [
        "// Function to find the lowest common ancestor of two nodes in a binary tree",
        "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {",
        "    if (root == NULL)",
        "        return NULL;",
        "    if (root->data == p->data || root->data == q->data)",
        "        return root;",
        "",
        "    TreeNode* left = lowestCommonAncestor(root->left, p, q);",
        "    TreeNode* right = lowestCommonAncestor(root->right, p, q);",
        "",
        "    if (!left)",
        "        return right;",
        "    if (!right)",
        "        return left;",
        "",
        "    return root;",
        "}"
      ],
      "description": "Find the lowest common ancestor of two nodes in a binary tree."
    },

    "Build Tree from Preorder and Inorder": {
      "prefix": "XBTBuildTreePreIn",
      "body": [
        "// Helper function to construct a binary tree from preorder and inorder traversal sequences",
        "TreeNode* preinhelper(vector<int>& preorder, vector<int>& inorder, int preStart,",
        "                      int preEnd, int inStart, int inEnd) {",
        "    if (preStart <= preEnd) {",
        "        TreeNode* node = new TreeNode(preorder[preStart]);",
        "        int ind = -1;",
        "        for (int i = inStart; i <= inEnd; i++) {",
        "            if (inorder[i] == preorder[preStart]) {",
        "                ind = i;",
        "                break;",
        "            }",
        "        }",
        "        int lElements = ind - inStart;",
        "        node->left =",
        "            preinhelper(preorder, inorder, preStart + 1, preStart + lElements,",
        "                      inStart, inStart + lElements - 1);",
        "        node->right = preinhelper(preorder, inorder, preStart + 1 + lElements, preEnd,",
        "                             ind + 1, inEnd);",
        "",
        "        return node;",
        "    } else {",
        "        return NULL;",
        "    }",
        "}",
        "",
        "// Function to construct a binary tree from preorder and inorder traversal sequences",
        "TreeNode* buildTreeprein(vector<int>& preorder, vector<int>& inorder) {",
        "    int n = preorder.size();",
        "    TreeNode* root = preinhelper(preorder, inorder, 0, n - 1, 0, n - 1);",
        "",
        "    return root;",
        "}"
      ],
      "description": "Construct a binary tree from preorder and inorder traversal sequences."
    },

    "Build Tree from Postorder and Inorder": {
      "prefix": "XBTBuildTreePostIn",
      "body": [
        "// Helper function to construct a binary tree from postorder and inorder traversal sequences",
        "TreeNode* postinhelper(vector<int>& inorder, vector<int>& postorder, int inStart,",
        "                       int inEnd, int poStart, int poEnd) {",
        "    if (inStart == inEnd) {",
        "        return new TreeNode(inorder[inStart]);",
        "    } else if (inStart > inEnd)",
        "        return NULL;",
        "",
        "    TreeNode* root = new TreeNode(postorder[poEnd]);",
        "",
        "    // finding index of poEnd in inorder",
        "    int ind;",
        "    for (int i = inStart; i <= inEnd; i++) {",
        "        if (inorder[i] == postorder[poEnd]) {",
        "            ind = i;",
        "            break;",
        "        }",
        "    }",
        "    int eleLeft = ind - inStart;",
        "    int eleRight = inEnd - ind;",
        "",
        "    root->left = postinhelper(inorder, postorder, inStart, ind - 1, poStart,",
        "                              poStart + eleLeft - 1);",
        "    root->right = postinhelper(inorder, postorder, ind + 1, inEnd, poEnd - eleRight,",
        "                               poEnd - 1);",
        "",
        "    return root;",
        "}",
        "",
        "// Function to construct a binary tree from postorder and inorder traversal sequences",
        "TreeNode* buildTreepostin(vector<int>& inorder, vector<int>& postorder) {",
        "    int n = inorder.size();",
        "",
        "    int inStart = 0, inEnd = n - 1, poStart = 0, poEnd = n - 1;",
        "",
        "    TreeNode* root = postinhelper(inorder, postorder, inStart, inEnd, poStart, poEnd);",
        "",
        "    return root;",
        "}"
      ],
      "description": "Construct a binary tree from postorder and inorder traversal sequences."
    },

    "BFS of Graph": {
      "prefix": "XGBFS",
      "body": [
        "// Function to perform BFS traversal of a graph",
        "vector<int> bfsOfGraph(int n, vector<int> adj[]) {",
        "    vector<int> ans;",
        "    vector<int> vis(n, 0);",
        "    queue<int> q;",
        "    for (int i = 0; i < n; i++) {",
        "        if (!vis[i]) {",
        "            vis[i] = 1;",
        "            q.push(i);",
        "            while (!q.empty()) {",
        "                int node = q.front();",
        "                q.pop();",
        "",
        "                ans.push_back(node);",
        "",
        "                for (auto it : adj[node]) {",
        "                    if (!vis[it]) {",
        "                        vis[it] = 1;",
        "                        q.push(it);",
        "                    }",
        "                }",
        "            }",
        "        }",
        "    }",
        "    return ans;",
        "}"
      ],
      "description": "Perform BFS traversal of a graph."
    },

    "DFS of Graph": {
      "prefix": "XGDFS",
      "body": [
        "// Function to perform DFS traversal of a graph",
        "void dfs(int i, vector<int>& ans, vector<int>& vis, vector<int> adj[]) {",
        "    vis[i] = 1;",
        "    ans.push_back(i);",
        "    for (auto it : adj[i]) {",
        "        if (!vis[it]) {",
        "            dfs(it, ans, vis, adj);",
        "        }",
        "    }",
        "    return;",
        "}",
        "",
        "vector<int> dfsOfGraph(int n, vector<int> adj[]) {",
        "    vector<int> ans;",
        "    vector<int> vis(n, 0);",
        "    dfs(0, ans, vis, adj);",
        "",
        "    return ans;",
        "}"
      ],
      "description": "Perform DFS traversal of a graph."
    },

    "Search in BST": {
      "prefix": "XBSTSearchBST",
      "body": [
        "// Function to search for a value in a Binary Search Tree (BST)",
        "TreeNode* searchBST(TreeNode* root, int val) {",
        "    if (root == NULL)",
        "        return NULL;",
        "    if (root->val == val)",
        "        return root;",
        "    else if (root->val > val)",
        "        return searchBST(root->left, val);",
        "    else",
        "        return searchBST(root->right, val);",
        "}"
      ],
      "description": "Search for a value in a Binary Search Tree (BST)."
    },

    "Insert into BST": {
      "prefix": "XLLInsertBST",
      "body": [
        "// Function to insert a value into a Binary Search Tree (BST)",
        "TreeNode* insertIntoBST(TreeNode* root, int val) {",
        "    if (!root)",
        "        return new TreeNode(val);",
        "",
        "    if (val > root->val)",
        "        root->right = insertIntoBST(root->right, val);",
        "    else",
        "        root->left = insertIntoBST(root->left, val);",
        "",
        "    return root;",
        "}"
      ],
      "description": "Insert a value into a Binary Search Tree (BST)."
    },

    "Delete from BST": {
      "prefix": "XBSTDeleteBST",
      "body": [
        "// Function to delete a value from a Binary Search Tree (BST)",
        "TreeNode* deleteNode(TreeNode* root, int key) {",
        "    if (root)",
        "        if (key < root->val)",
        "            root->left = deleteNode(root->left, key);",
        "        else if (key > root->val)",
        "            root->right = deleteNode(root->right, key);",
        "        else {",
        "            if (!root->left && !root->right)",
        "                return NULL;",
        "            if (!root->left || !root->right)",
        "                return root->left ? root->left : root->right;",
        "            TreeNode* temp = root->left;",
        "            while (temp->right != NULL)",
        "                temp = temp->right;",
        "            root->val = temp->val;",
        "            root->left = deleteNode(root->left, temp->val);",
        "        }",
        "    return root;",
        "}"
      ],
      "description": "Delete a value from a Binary Search Tree (BST)."
    },

    "Validate BST": {
      "prefix": "XBSTValidateBST",
      "body": [
        "// Helper function to perform inorder traversal and validate BST property",
        "void helperValidate(TreeNode* root, vector<int>& order) {",
        "    if (root == NULL)",
        "        return;",
        "",
        "    helperValidate(root->left, order);",
        "    order.push_back(root->val);",
        "    helperValidate(root->right, order);",
        "    return;",
        "}",
        "",
        "// Function to validate whether a Binary Tree is a Binary Search Tree (BST)",
        "bool isValidBST(TreeNode* root) {",
        "    vector<int> order;",
        "    helperValidate(root, order);",
        "    for (int i = 1; i < order.size(); i++) {",
        "        if (order[i] <= order[i - 1]) {",
        "            return false;",
        "        }",
        "    }",
        "    return true;",
        "}"
      ],
      "description": "Validate whether a Binary Tree is a Binary Search Tree (BST)."
    },
}